<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Executive library for Arduino: Executive Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Executive library for Arduino
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_executive-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Executive Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_executive_8h_source.html">Executive.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8532e6a2b370021ebeb563130cc5fd43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#a8532e6a2b370021ebeb563130cc5fd43">Executive</a> (int maxTasks=<a class="el" href="_executive_8h.html#a31cda3888ce1b1887af34684de618119">DEFAULT_MAX_TASKS</a>)</td></tr>
<tr class="separator:a8532e6a2b370021ebeb563130cc5fd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce80c499f7640b1770ade77cf56d965"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#a4ce80c499f7640b1770ade77cf56d965">~Executive</a> ()</td></tr>
<tr class="separator:a4ce80c499f7640b1770ade77cf56d965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52b5408a6c96b18ae9ccb9c54f74cac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#aa52b5408a6c96b18ae9ccb9c54f74cac">addTask</a> (unsigned long interval_ms, void(*doTask)(void), unsigned long timeToNext_ms=0)</td></tr>
<tr class="separator:aa52b5408a6c96b18ae9ccb9c54f74cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccbe297c783c28dd3cb840a20595bf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#a0ccbe297c783c28dd3cb840a20595bf1">addOneShotTask</a> (void(*doTask)(void), unsigned long timeToNext_ms=0)</td></tr>
<tr class="separator:a0ccbe297c783c28dd3cb840a20595bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4112ece22b4c0797b19da69460cb54c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#a4112ece22b4c0797b19da69460cb54c5">enableTask</a> (int taskNo)</td></tr>
<tr class="separator:a4112ece22b4c0797b19da69460cb54c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c7ec581df5cf93fbcd129e2b0bd3db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#a34c7ec581df5cf93fbcd129e2b0bd3db">disableTask</a> (int taskNo)</td></tr>
<tr class="separator:a34c7ec581df5cf93fbcd129e2b0bd3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747a0a1f89761033d794ecd9e1e0c4c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#a747a0a1f89761033d794ecd9e1e0c4c4">modifyTaskInterval</a> (int taskNo, unsigned long interval_ms)</td></tr>
<tr class="separator:a747a0a1f89761033d794ecd9e1e0c4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935ee35ce112fea897a085f6f4dafa7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#ae935ee35ce112fea897a085f6f4dafa7">modifyTaskNextRun</a> (int taskNo, unsigned long timeToNext_ms)</td></tr>
<tr class="separator:ae935ee35ce112fea897a085f6f4dafa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6261a1fface4ef81c319f77a3597209a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#a6261a1fface4ef81c319f77a3597209a">removeTask</a> (int taskNo)</td></tr>
<tr class="separator:a6261a1fface4ef81c319f77a3597209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff32f202e1d5831b36c0444a0a76937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#a3ff32f202e1d5831b36c0444a0a76937">yield</a> (void)</td></tr>
<tr class="separator:a3ff32f202e1d5831b36c0444a0a76937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67390d94965f57eccb526d7c04eb55ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay</a> (unsigned long delay_ms)</td></tr>
<tr class="separator:a67390d94965f57eccb526d7c04eb55ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccc0ce74390239ade1ad547739ee1ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#afccc0ce74390239ade1ad547739ee1ce">loop</a> (void)</td></tr>
<tr class="separator:afccc0ce74390239ade1ad547739ee1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac24106308357647b7b79c9c384a1ab94"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_executive.html#ac24106308357647b7b79c9c384a1ab94">DELAY_FOREVER</a> = -1L</td></tr>
<tr class="separator:ac24106308357647b7b79c9c384a1ab94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8532e6a2b370021ebeb563130cc5fd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8532e6a2b370021ebeb563130cc5fd43">&#9670;&nbsp;</a></span>Executive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executive::Executive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxTasks</em> = <code><a class="el" href="_executive_8h.html#a31cda3888ce1b1887af34684de618119">DEFAULT_MAX_TASKS</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the Exec object with a specified size of task table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxTasks</td><td>The maximum number of tasks (enabled+disabled) in the task list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ce80c499f7640b1770ade77cf56d965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce80c499f7640b1770ade77cf56d965">&#9670;&nbsp;</a></span>~Executive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executive::~Executive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0ccbe297c783c28dd3cb840a20595bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccbe297c783c28dd3cb840a20595bf1">&#9670;&nbsp;</a></span>addOneShotTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Executive::addOneShotTask </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>doTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeToNext_ms</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new task to be performed just once</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeToNext_ms</td><td>Number of ms until first run of the task to do. </td></tr>
    <tr><td class="paramname">doTask</td><td>The routine called to do the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index to the task or -1 if task could not be added (no room left in task table) </dd></dl>

</div>
</div>
<a id="aa52b5408a6c96b18ae9ccb9c54f74cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52b5408a6c96b18ae9ccb9c54f74cac">&#9670;&nbsp;</a></span>addTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Executive::addTask </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>interval_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>doTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeToNext_ms</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new task to be performed at a regular interval</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeToNext_ms</td><td>Number of ms until first run of the task to do. Must be less than interval_ms otherwise taken as interval_ms </td></tr>
    <tr><td class="paramname">interval_ms</td><td>Interval between successive runs of the task </td></tr>
    <tr><td class="paramname">doTask</td><td>The routine called to do the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index to the task or -1 if task could not be added (no room left in task table) </dd></dl>

</div>
</div>
<a id="a67390d94965f57eccb526d7c04eb55ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67390d94965f57eccb526d7c04eb55ad">&#9670;&nbsp;</a></span>delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executive::delay </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>delay_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run tasks in the schedule that need to be run in the next delay_ms milliseconds. Return after at least delay_ms. I.e. the function will call the standard <a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay()</a> function to use up any 'spare' time after any relevant tasks have been run.</p>
<p>Tasks are not run in parallel, so if a task become due to be run during the execution of another task it will have to wait until the current task completes before it can be started.</p>
<p>When considering which task to run, the task with the earliest desired start time will always take priority. Where two tasks have the same desired start time, the one earliest in the list will take precedence. You should aim to place the tasks with shortest intervals near the top of the list as they stand the best chance of running to their desired interval.</p>
<p>Immediately before running a task, the time at it is started is recorded. The desired time of the next execution will be based on the actual time at which the task is started and the task interval. There is no account taken of whether the task was late in starting. This effectively means that the task interval is a minimum setting for the amount of time between successive calls to the task function. In the best case, where the <a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay()</a> function has control for most of the time and other scheduled functions don't interfere, the interval time will be honoured and the task will operate at the requested interval. If the sketch spends a lot of its time outside the <a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay()</a> function or if there are other tasks that individually or in combination might take longer then the interval, then <a class="el" href="class_executive.html">Executive</a> won't be able to keep to the schedule and will work on a 'best endeavours' basis.</p>
<p>One-shot tasks are treated equally to the interval tasks, except that they are removed from the table immediately before this scheduler runs their doTask() function.</p>
<p>If a task is started and runs beyond the delay_ms window then this <a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">Executive::delay()</a> function will itself return as soon as that task completes. In this case no further tasks will be started (even if they were due to run in that delay_ms window).</p>
<p>If, when <a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay()</a> is called, there is a backlog of tasks that are due to be run, then the tasks get run in the order of their desired run time. Again, if the end of the delay_ms is reached, then the <a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay()</a> function will return as soon as the current task finishes, even if there are other back-logged or due to run tasks. This behaviour does ensure that if there is a backlog of tasks then at least one of these will get run for any call to <a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay()</a>.</p>
<p>If there are no tasks due to run in the requested delay_ms window then the <a class="el" href="class_executive.html">Executive</a>:<a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay()</a> function just behaves like a standard <a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay_ms</td><td>The minimum amount of time to remain in this scheduling function. Return after this time has passed and a soon as any currently executing task returns. If the special value DELAY_FOREVER is used then the control is passed entirely to <a class="el" href="class_executive.html">Executive</a> and is never returned back to the calling sketch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_executive.html#afccc0ce74390239ade1ad547739ee1ce">Executive::loop()</a> </dd></dl>

</div>
</div>
<a id="a34c7ec581df5cf93fbcd129e2b0bd3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c7ec581df5cf93fbcd129e2b0bd3db">&#9670;&nbsp;</a></span>disableTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Executive::disableTask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>taskNo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable the specified task from being scheduled (run)</p>
<p>Task can be one-shot or continuous but must have been set up previously. If the task is one-shot then it must be disabled before it first runs or this routine will return -1. One-shot tasks are deleted from the table immediately before they are run. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskNo</td><td>Number of the task that is to be disabled. The task number is returned from <a class="el" href="class_executive.html#aa52b5408a6c96b18ae9ccb9c54f74cac">addTask()</a> and addOnShotTask(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task no or -1 if the taskNo was not a valid task </dd></dl>

</div>
</div>
<a id="a4112ece22b4c0797b19da69460cb54c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4112ece22b4c0797b19da69460cb54c5">&#9670;&nbsp;</a></span>enableTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Executive::enableTask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>taskNo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable the specified task and make eligible to run immediately</p>
<p>Task can be one-shot or continuous but must have been set up previously. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskNo</td><td>Number of the task that is to be enabled. The task number is returned from <a class="el" href="class_executive.html#aa52b5408a6c96b18ae9ccb9c54f74cac">addTask()</a> and addOnShotTask(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task no or -1 if the taskNo was not a valid task </dd></dl>

</div>
</div>
<a id="afccc0ce74390239ade1ad547739ee1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccc0ce74390239ade1ad547739ee1ce">&#9670;&nbsp;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executive::loop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hand over control to the <a class="el" href="class_executive.html">Executive</a>. Run tasks to the schedule but never return. </p>

</div>
</div>
<a id="a747a0a1f89761033d794ecd9e1e0c4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747a0a1f89761033d794ecd9e1e0c4c4">&#9670;&nbsp;</a></span>modifyTaskInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Executive::modifyTaskInterval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>taskNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>interval_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify the interval at which a task runs or the time until a one-shot is executed</p>
<p>For continuously running tasks, only the interval is changed, so if it is shortened, the task may immediately become eligible to run (during the next <a class="el" href="class_executive.html#a3ff32f202e1d5831b36c0444a0a76937">yield()</a> or <a class="el" href="class_executive.html#a67390d94965f57eccb526d7c04eb55ad">delay()</a>).</p>
<p>For one-shot tasks, the 'timer' is reset so it will become eligible after the new interval_ms period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskNo</td><td></td></tr>
    <tr><td class="paramname">interval_ms</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task no or -1 if the taskNo was not a valid task </dd></dl>

</div>
</div>
<a id="ae935ee35ce112fea897a085f6f4dafa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935ee35ce112fea897a085f6f4dafa7">&#9670;&nbsp;</a></span>modifyTaskNextRun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Executive::modifyTaskNextRun </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>taskNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeToNext_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the time at which the task will next run</p>
<p>Note that for one-shot tasks, this behaves the same as <a class="el" href="class_executive.html#a747a0a1f89761033d794ecd9e1e0c4c4">modifyTaskInterval()</a> and the internal 'timer' is effectively reset.</p>
<p>For continuously running tasks, the timeToNext_ms should be less than or equal to the interval_ms for the task. If greater, then interval_ms is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskNo</td><td></td></tr>
    <tr><td class="paramname">timeToNext_ms</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task no or -1 if the taskNo was not a valid task </dd></dl>

</div>
</div>
<a id="a6261a1fface4ef81c319f77a3597209a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6261a1fface4ef81c319f77a3597209a">&#9670;&nbsp;</a></span>removeTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Executive::removeTask </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>taskNo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately removes a task from the task schedule</p>
<p>Note that this doesn't stop a running task, it will just prevent the task from being run again.</p>
<p>After removing a task, its taskNo is not longer valid and should be discarded as the taskNo may get re-used on a subsequent call to <a class="el" href="class_executive.html#aa52b5408a6c96b18ae9ccb9c54f74cac">addTask()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskNo</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task no of the removed task (which is no longer useful) or -1 if the taskNo was not a valid task. </dd></dl>

</div>
</div>
<a id="a3ff32f202e1d5831b36c0444a0a76937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff32f202e1d5831b36c0444a0a76937">&#9670;&nbsp;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executive::yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run the task that is most overdue to run.</p>
<p>Only the most overdue task is run. If there are no overdue tasks this routine returns after a short delay (MIN_YIELD_TIME_MS). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac24106308357647b7b79c9c384a1ab94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24106308357647b7b79c9c384a1ab94">&#9670;&nbsp;</a></span>DELAY_FOREVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long Executive::DELAY_FOREVER = -1L</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use in a call to Exec.delay() this will cause an infinite delay. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/jim/Developer/Arduino/Sketches/libraries/Executive/src/<a class="el" href="_executive_8h_source.html">Executive.h</a></li>
<li>/Users/jim/Developer/Arduino/Sketches/libraries/Executive/src/<a class="el" href="_executive_8cpp.html">Executive.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
